use crate::pacman::get_explicit_packages;
use crate::printer::{print_error, print_warning};
use crate::users::{get_users};
use serde::{Deserialize, Serialize};
use std::path::Path;
use std::{fs, process};

#[derive(Serialize, Deserialize, Debug)]
pub struct UserConfig {
    pub user: String,
    pub groups: Vec<String>,
    pub displayname: String,
    pub shell: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SysConfig {
    pub autogenerated: Option<(bool, String, String)>,
    pub packages: Option<Vec<String>>,
    pub shells: Option<Vec<String>>,
    pub users: Option<Vec<UserConfig>>,
}

impl Default for SysConfig {
    fn default() -> Self {
        Self {
            autogenerated: Some((
                true,
                "All the packages retrieved from your pacman -Qe will be added to packages entry. All the shells from /etc/shells will be in shells entry.".to_string(),
                "You can remove this config entry with explanations for a cleaner config.".to_string()
            )),
            packages: Some(get_explicit_packages()),
            shells: Some(get_shells()),
            users: Some(get_users()),
        }
    }
}

impl SysConfig {
    pub fn read_or_generate_config(path: &str) -> SysConfig {
        if !Path::new(path).exists() {
            return generate_base_config(path);
        }

        let raw = fs::read_to_string(path).unwrap_or_else(|e| {
            print_error(
                &format!("Could not read file: {}", path),
                Some(&e.to_string()),
            );

            process::exit(1);
        });

        parse_config(Some(raw))
    }

    pub fn validate_config(&self) -> bool {
        if let Some(pkgs) = &self.packages
            && pkgs.iter().any(|x| x.is_empty())
        {
            print_error("packages must contain only non-empty strings", None);
            return false;
        }

        if let Some(shells) = &self.shells
            && shells.iter().any(|x| x.is_empty())
        {
            print_error("shells must contain only non-empty strings", None);
            return false;
        }

        true
    }

    pub fn difference(&self, prev: &SysConfig) -> (Vec<String>, Vec<String>) {
        let add: Vec<String> = self
            .packages
            .clone()
            .unwrap_or(vec![])
            .iter()
            .filter(|x| !prev.packages.as_ref().unwrap_or(&vec![]).contains(x))
            .cloned()
            .collect();

        let remove: Vec<String> = prev
            .packages
            .as_ref()
            .unwrap_or(&vec![])
            .iter()
            .filter(|x| !self.packages.clone().unwrap_or(vec![]).contains(x))
            .cloned()
            .collect();

        (add, remove)
    }
}

fn generate_base_config(path: &str) -> SysConfig {
    println!("generating base system configuration");

    let cfg = SysConfig::default();
    let dump = toml::to_string_pretty(&cfg).unwrap(); // TODO: error handling

    if let Err(e) = fs::write(path, &dump) {
        print_error("Failed to write autogenerated config", Some(&e.to_string()));
        process::exit(1);
    }

    println!("autogenerated config written to {}", path);

    cfg
}

pub fn read_file(path: &str) -> Option<String> {
    match fs::read_to_string(path) {
        Ok(s) => Some(s),
        Err(e) => {
            print_warning(
                &format!("Could not read file: {}", path),
                Some(&e.to_string()),
            );

            None
        }
    }
}

pub fn parse_config(raw: Option<String>) -> SysConfig {
    match raw {
        Some(data) => toml::from_str(&data).unwrap_or_else(|e| {
            print_warning("Invalid TOML configuration", Some(&e.to_string()));
            SysConfig::default()
        }),
        None => SysConfig::default(),
    }
}

fn get_shells() -> Vec<String> {
    fs::read_to_string("/etc/shells")
        .unwrap_or_default()
        .lines()
        .filter(|l| !l.starts_with('#') && !l.trim().is_empty())
        .map(|s| s.to_string())
        .collect()
}

pub fn save_old_config(raw: &str) {
    if let Err(e) = fs::write("/etc/sysconfig.old", raw) {
        print_error("Could not write old config", Some(&e.to_string()));
    }
}
