use crate::pacman::get_explicit_packages;
use crate::printer::{print_error, print_warning};
use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Serialize, Deserialize, Debug, Default)]
pub struct SysConfig {
    pub autogenerated: Option<(bool, String, String)>,
    pub packages: Option<Vec<String>>,
    pub shells: Option<Vec<String>>,
}

impl SysConfig {
    pub fn read_or_generate_config(path: &str) -> SysConfig {
        if !std::path::Path::new(path).exists() {
            return generate_base_config(path);
        }

        let raw = fs::read_to_string(path).unwrap_or_else(|e| {
            print_error(
                &format!("Could not read file: {}", path),
                Some(&e.to_string()),
            );
            std::process::exit(1);
        });

        parse_config(Some(raw))
    }

    pub fn validate_config(&self) -> bool {
        if let Some(pkgs) = &self.packages
            && pkgs.iter().any(|x| x.is_empty())
        {
            print_error("packages must contain only non-empty strings", None);
            return false;
        }
        if let Some(shells) = &self.shells
            && shells.iter().any(|x| x.is_empty())
        {
            print_error("shells must contain only non-empty strings", None);
            return false;
        }
        true
    }

    pub fn difference(&self, prev: &[String]) -> (Vec<String>, Vec<String>) {
        let add: Vec<String> = self
            .packages
            .clone()
            .unwrap_or(vec![])
            .iter()
            .filter(|x| !prev.contains(x))
            .cloned()
            .collect();
        let remove: Vec<String> = prev
            .iter()
            .filter(|x| !self.packages.clone().unwrap_or(vec![]).contains(x))
            .cloned()
            .collect();
        (add, remove)
    }
}

fn generate_base_config(path: &str) -> SysConfig {
    println!("generating base system configuration");

    let cfg = SysConfig {
        autogenerated: Some((
            true,
            "All the packages retrieved from your pacman -Qe will be added to packages entry. All the shells from /etc/shells will be in shells entry.".to_string(),
            "You can remove this config entry with explanations for a cleaner config.".to_string()
        )),
        packages: Some(get_explicit_packages()),
        shells: Some(get_shells()),
    };

    let json = serde_json::to_string_pretty(&cfg).unwrap();

    if let Err(e) = fs::write(path, &json) {
        print_error("Failed to write autogenerated config", Some(&e.to_string()));
        std::process::exit(1);
    }

    println!("autogenerated config written to {}", path);
    cfg
}

pub fn read_file(path: &str) -> Option<String> {
    match fs::read_to_string(path) {
        Ok(s) => Some(s),
        Err(e) => {
            print_warning(
                &format!("Could not read file: {}", path),
                Some(&e.to_string()),
            );
            None
        }
    }
}

pub fn parse_config(raw: Option<String>) -> SysConfig {
    match raw {
        Some(data) => serde_json::from_str(&data).unwrap_or_else(|e| {
            print_warning("Invalid JSON configuration", Some(&e.to_string()));
            SysConfig::default()
        }),
        None => SysConfig::default(),
    }
}

fn get_shells() -> Vec<String> {
    fs::read_to_string("/etc/shells")
        .unwrap_or_default()
        .lines()
        .filter(|l| !l.starts_with('#') && !l.trim().is_empty())
        .map(|s| s.to_string())
        .collect()
}

pub fn save_old_config(raw: &str) {
    if let Err(e) = fs::write("/etc/sysconfig.old", raw) {
        print_error("Could not write old config", Some(&e.to_string()));
    }
}
