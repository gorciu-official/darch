use serde::{Deserialize, Serialize};
use std::fs;
use std::process::Command;

#[derive(Serialize, Deserialize, Debug)]
struct SysConfig {
    autogenerated: Option<(bool, String, String)>,
    packages: Option<Vec<String>>,
    shells: Option<Vec<String>>,
}

impl Default for SysConfig {
    fn default() -> Self {
        Self {
            autogenerated: None,
            packages: None,
            shells: None
        }
    }
}

fn print_error(msg: &str, detail: Option<&str>) {
    eprintln!("[\x1b[91m ERROR \x1b[0m] {}", msg);
    if let Some(d) = detail {
        eprintln!("  -> {}", d);
    }
}

fn print_warning(msg: &str, detail: Option<&str>) {
    eprintln!("[\x1b[93m WARN \x1b[0m] {}", msg);
    if let Some(d) = detail {
        eprintln!("  -> {}", d);
    }
}

fn print_header(msg: &str) {
    println!("\x1b[34m### \x1b[0;1m{}\x1b[0m", msg);
}

fn read_file(path: &str) -> Option<String> {
    match fs::read_to_string(path) {
        Ok(s) => Some(s),
        Err(e) => {
            print_warning(&format!("Could not read file: {}", path), Some(&e.to_string()));
            None
        }
    }
}

fn parse_config(raw: Option<String>) -> SysConfig {
    match raw {
        Some(data) => match serde_json::from_str(&data) {
            Ok(cfg) => cfg,
            Err(e) => {
                print_warning("Invalid JSON configuration", Some(&e.to_string()));
                SysConfig::default()
            }
        },
        None => SysConfig::default(),
    }
}

fn save_old_config(raw: &str) {
    if let Err(e) = fs::write("/etc/sysconfig.old", raw) {
        print_error("Could not write old config", Some(&e.to_string()));
    }
}

fn validate_config(cfg: &SysConfig) -> bool {
    if let Some(pkgs) = &cfg.packages {
        if pkgs.iter().any(|x| x.is_empty()) {
            print_error("packages must contain only non-empty strings", None);
            return false;
        }
    }
    if let Some(shells) = &cfg.shells {
        if shells.iter().any(|x| x.is_empty()) {
            print_error("shells must contain only non-empty strings", None);
            return false;
        }
    }
    true
}

fn difference(prev: &[String], current: &[String]) -> (Vec<String>, Vec<String>) {
    let add: Vec<String> = current.iter().filter(|x| !prev.contains(x)).cloned().collect();
    let remove: Vec<String> = prev.iter().filter(|x| !current.contains(x)).cloned().collect();
    (add, remove)
}

fn run(cmd: &str, args: &[&str]) -> bool {
    let status = Command::new(cmd)
        .args(args)
        .status();
    match status {
        Ok(s) => s.success(),
        Err(e) => {
            print_error("Failed to run command", Some(&e.to_string()));
            false
        }
    }
}

fn is_installed(pkg: &str) -> bool {
    Command::new("pacman")
        .args(&["-Qi", pkg])
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .status()
        .map(|s| s.success())
        .unwrap_or(false)
}

fn install_if_missing(packages: &[String]) -> bool {
    let missing: Vec<&String> = packages.iter().filter(|p| !is_installed(p)).collect();
    if missing.is_empty() {
        println!("added packages already installed before by pacman");
        return true;
    }
    let args: Vec<&str> = ["-S", "--color", "never"].into_iter().chain(missing.iter().map(|s| s.as_str())).collect();
    run("/usr/bin/pacman", &args)
}

fn check_for_shell_warnings() {
    let users_file = fs::read_to_string("/etc/passwd").unwrap_or_default();
    let shell_file = fs::read_to_string("/etc/shells").unwrap_or_default();
    let shells: Vec<&str> = shell_file.lines().filter(|l| !l.starts_with('#') && !l.trim().is_empty()).collect();
    for user in users_file.lines() {
        let parts: Vec<&str> = user.split(':').collect();
        if parts.len() < 7 { continue; }
        let username = parts[0];
        let displayname = parts[4];
        let shell = parts[6];
        if shell == "nologin" || shell == "/bin/nologin" || shell == "/usr/bin/nologin" { continue; }
        if !shells.contains(&shell) {
            print_warning(
                &format!("Applying this system configuration breaks shell for {} ({})", if !displayname.trim().is_empty() { displayname } else { username }, username),
                Some(&format!("Shell {} is not in /etc/shells", shell))
            );
        }
    }
}

fn get_explicit_packages() -> Vec<String> {
    let output = Command::new("pacman")
        .args(&["-Qe"])
        .output()
        .unwrap_or_else(|_| {
            print_error("Failed to run pacman -Qe", None);
            std::process::exit(1);
        });

    String::from_utf8_lossy(&output.stdout)
        .lines()
        .filter_map(|l| l.split_whitespace().next())
        .map(|s| s.to_string())
        .collect()
}

fn get_shells() -> Vec<String> {
    fs::read_to_string("/etc/shells")
        .unwrap_or_default()
        .lines()
        .filter(|l| !l.starts_with('#') && !l.trim().is_empty())
        .map(|s| s.to_string())
        .collect()
}

fn generate_base_config(path: &str) -> SysConfig {
    println!("generating base system configuration");

    let cfg = SysConfig {
        autogenerated: Some((
            true,
            "All the packages retrieved from your pacman -Qe will be added to packages entry. All the shells from /etc/shells will be in shells entry.".to_string(),
            "You can remove this config entry with explanations for a cleaner config.".to_string()
        )),
        packages: Some(get_explicit_packages()),
        shells: Some(get_shells()),
    };

    let json = serde_json::to_string_pretty(&cfg).unwrap();

    if let Err(e) = fs::write(path, &json) {
        print_error("Failed to write autogenerated config", Some(&e.to_string()));
        std::process::exit(1);
    }

    println!("autogenerated config written to {}", path);
    cfg
}

fn read_or_generate_config(path: &str) -> SysConfig {
    if !std::path::Path::new(path).exists() {
        return generate_base_config(path);
    }

    let raw = fs::read_to_string(path).unwrap_or_else(|e| {
        print_error(&format!("Could not read file: {}", path), Some(&e.to_string()));
        std::process::exit(1);
    });

    parse_config(Some(raw))
}

fn main() {
    print_header("Processing system configuration");

    let cfg = read_or_generate_config("/etc/sysconfig");
    let prev = parse_config(read_file("/etc/sysconfig.old"));

    if !validate_config(&cfg) {
        print_error("Config validation failed. Aborting.", None);
        std::process::exit(-1);
    }

    if !validate_config(&prev) {
        print_error("Old config validation failed. Aborting.", None);
        std::process::exit(-1);
    }

    let (add, remove) = difference(prev.packages.as_ref().unwrap_or(&vec![]), cfg.packages.as_ref().unwrap_or(&vec![]));

    print_header("Upgrading system");
    run("/usr/bin/pacman", &["-Syu", "--color", "never"]);
    if cfg.packages.as_ref().map_or(false, |p| p.contains(&"flatpak".to_string())) {
        run("/usr/bin/flatpak", &["update"]);
    }
    if cfg.packages.as_ref().map_or(false, |p| p.contains(&"yay".to_string())) {
        run("/usr/bin/yay", &[]);
    }
    if cfg.packages.as_ref().map_or(false, |p| p.contains(&"paru".to_string())) {
        print_warning("We strongly recommend you to use yay instead of paru.", None);
        run("/usr/bin/paru", &[]);
    }

    print_header("Processing package changes");
    if !add.is_empty() && !install_if_missing(&add) {
        print_error("Failed to install packages. Fix configuration to remove the error.", None);
    }
    if !remove.is_empty() && !run("/usr/bin/pacman", &["-Rns", "--color", "never"]) {
        print_error("Failed to remove packages. Fix configuration to remove the error.", None);
    }
    if add.is_empty() && remove.is_empty() {
        println!("packages unchanged");
    }

    print_header("Rebuilding system configuration");

    let shells_data = cfg.shells.as_ref().map(|s| s.join("\n")).unwrap_or(String::from(r#"
/bin/sh
/bin/bash
/bin/rbash
/usr/bin/sh
/usr/bin/bash
/usr/bin/rbash
/usr/bin/systemd-home-fallback-shell
/usr/bin/git-shell"#));

    fs::write("/etc/shells", format!(
        "# file autogenerated\n# please edit the system configuration at /etc/sysconfig instead\n\n# Pathnames of valid login shells.\n# See shells(5) for details.\n\n{}",
        shells_data
    )).unwrap_or_else(|e| print_error("Failed to write /etc/shells", Some(&e.to_string())));

    check_for_shell_warnings();

    print_header("Backing up config");
    save_old_config(&read_file("/etc/sysconfig").unwrap_or_default());
    println!("config backed up to /etc/sysconfig.old");
}
